{"version":3,"file":"useNpmPackages-CDW_1T6z.js","sources":["../../src/hooks/useNpmPackages.ts"],"sourcesContent":["import { useCallback, useEffect, useRef, useState } from \"react\";\n\n// ---------------- Types ----------------\nexport interface RawNpmSearchResultItem {\n  package: {\n    name: string;\n    version: string;\n    description?: string;\n    date?: string; // publish date\n    links: {\n      npm?: string;\n      homepage?: string;\n      repository?: string;\n      bugs?: string;\n    };\n    keywords?: string[];\n    publisher?: {\n      username: string;\n    };\n    maintainers?: { username: string }[];\n  };\n  score?: {\n    final: number;\n  };\n  searchScore?: number;\n}\n\nexport interface NpmPackageNormalized {\n  name: string;\n  version: string;\n  description: string;\n  publishedAt?: string;\n  homepage?: string;\n  repository?: string;\n  npmUrl?: string;\n  weeklyDownloads?: number; // optional enrichment\n  keywords: string[];\n}\n\ninterface UseNpmPackagesOptions {\n  maintainer?: string; // default: vaporjawn\n  size?: number; // limit results (npm search default 20). We'll default to 20 to capture new packages automatically.\n  cacheTtlMs?: number; // default 12h\n  fetchDownloads?: boolean; // default true - enrich with weekly downloads\n}\n\ninterface UseNpmPackagesState {\n  packages: NpmPackageNormalized[];\n  loading: boolean;\n  error: string | null;\n  refresh: () => void;\n}\n\nconst DEFAULT_CACHE_KEY = \"npm_packages_vaporjawn_v1\";\nconst DEFAULT_TTL = 1000 * 60 * 60 * 12; // 12 hours\n\ninterface CachedData {\n  fetchedAt: number;\n  data: NpmPackageNormalized[];\n}\n\n/**\n * Fetch weekly downloads for a package using npm downloads API.\n * Non-critical; failures are swallowed (we return undefined).\n */\nasync function fetchWeeklyDownloads(pkgName: string): Promise<number | undefined> {\n  try {\n    const resp = await fetch(`https://api.npmjs.org/downloads/point/last-week/${encodeURIComponent(pkgName)}`);\n    if (!resp.ok) return undefined;\n    const json = await resp.json();\n    if (typeof json.downloads === \"number\") return json.downloads;\n  } catch {\n    // ignore\n  }\n  return undefined;\n}\n\n/**\n * Normalize raw search item into our internal shape.\n */\nfunction normalize(item: RawNpmSearchResultItem): NpmPackageNormalized {\n  const p = item.package;\n  return {\n    name: p.name,\n    version: p.version,\n    description: p.description || \"\",\n    publishedAt: p.date,\n    homepage: p.links?.homepage,\n    repository: p.links?.repository,\n    npmUrl: p.links?.npm,\n    keywords: p.keywords || [],\n  };\n}\n\n/**\n * Hook to fetch & cache npm packages by maintainer. Implements stale-while-revalidate style:\n * - Returns cached data immediately if present & fresh\n * - Always triggers background revalidation (unless a fetch already running)\n */\nexport function useNpmPackages(options: UseNpmPackagesOptions = {}): UseNpmPackagesState {\n  const {\n    maintainer = \"vaporjawn\",\n    size = 20,\n    cacheTtlMs = DEFAULT_TTL,\n    fetchDownloads = true,\n  } = options;\n\n  const [packages, setPackages] = useState<NpmPackageNormalized[]>([]);\n  const [loading, setLoading] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n  const inFlightRef = useRef<boolean>(false);\n\n  const cacheKey = `${DEFAULT_CACHE_KEY}_${maintainer}_${size}`;\n\n  const readCache = useCallback((): CachedData | null => {\n    try {\n      const raw = localStorage.getItem(cacheKey);\n      if (!raw) return null;\n      const parsed = JSON.parse(raw) as CachedData;\n      if (!parsed.fetchedAt || !Array.isArray(parsed.data)) return null;\n      return parsed;\n  } catch {\n      return null;\n    }\n  }, [cacheKey]);\n\n  const writeCache = useCallback(\n    (data: NpmPackageNormalized[]) => {\n      try {\n        const payload: CachedData = { fetchedAt: Date.now(), data };\n        localStorage.setItem(cacheKey, JSON.stringify(payload));\n  } catch {\n        // ignore quota errors\n      }\n    },\n    [cacheKey]\n  );\n\n  const enrichDownloads = useCallback(async (items: NpmPackageNormalized[]) => {\n    if (!fetchDownloads) return items;\n    // Limit concurrent fetches to avoid hammering API (max 10 packages)\n    const slice = items.slice(0, 10);\n    const enriched = await Promise.all(\n      slice.map(async (p) => {\n        const weeklyDownloads = await fetchWeeklyDownloads(p.name);\n        return { ...p, weeklyDownloads };\n      })\n    );\n    // Merge enriched slice back\n    return items.map((p) => {\n      const enrichedMatch = enriched.find((e) => e.name === p.name);\n      return enrichedMatch || p;\n    });\n  }, [fetchDownloads]);\n\n  const fetchData = useCallback(async (force = false) => {\n    if (inFlightRef.current) return; // prevent duplicate fetches\n    inFlightRef.current = true;\n    setLoading(true);\n    setError(null);\n    try {\n      const url = `https://registry.npmjs.org/-/v1/search?text=maintainer:${encodeURIComponent(\n        maintainer\n      )}&size=${size}`;\n      const resp = await fetch(url);\n      if (!resp.ok) throw new Error(`npm search failed (${resp.status})`);\n      const json = await resp.json();\n      const items: RawNpmSearchResultItem[] = json.objects || [];\n      let normalized = items.map(normalize);\n\n      // Sort newest first (by published date)\n      normalized.sort((a, b) => {\n        const da = a.publishedAt ? new Date(a.publishedAt).getTime() : 0;\n        const db = b.publishedAt ? new Date(b.publishedAt).getTime() : 0;\n        return db - da;\n      });\n\n      normalized = await enrichDownloads(normalized);\n\n      setPackages(normalized);\n      writeCache(normalized);\n    } catch (e: unknown) {\n      if (!force) {\n        // Only set error if no usable cached data\n        if (e instanceof Error) {\n          setError(e.message);\n        } else {\n          setError(\"Failed to load npm packages\");\n        }\n      }\n    } finally {\n      setLoading(false);\n      inFlightRef.current = false;\n    }\n  }, [maintainer, size, enrichDownloads, writeCache]);\n\n  // Initial load (cache + revalidate)\n  useEffect(() => {\n    const cached = readCache();\n    if (cached) {\n      const isFresh = Date.now() - cached.fetchedAt < cacheTtlMs;\n      setPackages(cached.data);\n      // Revalidate if stale\n      if (!isFresh) {\n        fetchData();\n      }\n    } else {\n      fetchData();\n    }\n  }, [cacheTtlMs, readCache, fetchData]);\n\n  const refresh = useCallback(() => {\n    // Force bypass cache and fetch fresh data\n    fetchData(true);\n  }, [fetchData]);\n\n  return { packages, loading, error, refresh };\n}\n\nexport default useNpmPackages;\n"],"names":["DEFAULT_CACHE_KEY","DEFAULT_TTL","fetchWeeklyDownloads","pkgName","resp","json","normalize","item","p","_a","_b","_c","useNpmPackages","options","maintainer","size","cacheTtlMs","fetchDownloads","packages","setPackages","useState","loading","setLoading","error","setError","inFlightRef","useRef","cacheKey","readCache","useCallback","raw","parsed","writeCache","data","payload","enrichDownloads","items","slice","enriched","weeklyDownloads","e","fetchData","force","url","normalized","a","b","da","useEffect","cached","isFresh","refresh"],"mappings":"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"}